function inputs = mpc_controller(states, z_ref, u_init)
%% MPC Controller for lateral and longitudinal dynamics
% Includes a constarint on alpha_i and delta which takes the the fact into
% account that they act on the same servomotors
% Inputs:
%           states: [states_long; states_lat]
%           z_ref:  Reference signal for the altitude (minus sign)
%           u_init: Initial input

    % controller variables
    persistent param yalmip_optimizer_long input_long input_lat

    % initialize controller, if not done already
    if isempty(yalmip_optimizer_long)
        [param, yalmip_optimizer_long] = init();
        input_long = u_init(2:3);
        input_lat = u_init(1);
    end

    %% evaluate control action by solving MPC problem, e.g.
    [u_mpc,errorcode] = yalmip_optimizer_long([states(1:5) - [z_ref; param.states_eq_long]; input_long-param.u_eq_long; states(6:10)-param.states_eq_lat; input_lat-param.u_eq_lat]);
    if (errorcode ~= 0)
          warning('MPC infeasible');
    end
    %u_mpc = cell2mat(u_mpc);
    inputs = round(u_mpc, 5) + [param.u_eq_lat; param.u_eq_long];
    input_long = inputs(2:3);
    input_lat = inputs(1);
end

function [param, yalmip_optimizer] = init()
    % initializes the controller on first call and returns parameters and
    % Yalmip optimizer object

    param = control_parameter(); % get basic controller parameters
    A_long = param.A_long;
    B_long = param.B_long;
    A_lat = param.A_lat;
    B_lat = param.B_lat;

    %% implement your MPC using Yalmip here, e.g.
    N = param.N_long;
    nx_long = size(A_long,1);
    nu_long = size(B_long,2);
    nx_lat = size(A_lat,1);
    nu_lat = size(B_lat,2);
    
    U_long = sdpvar(repmat(nu_long,1,N-1),repmat(1,1,N-1),'full');
    X_long = sdpvar(repmat(nx_long,1,N),repmat(1,1,N),'full');
    eps1_long = sdpvar(repmat(nx_long,1,N-1),repmat(1,1,N-1), 'full');
    eps2_long = sdpvar(repmat(nx_long,1,N-1),repmat(1,1,N-1), 'full');

    U_lat = sdpvar(repmat(nu_lat,1,N-1),repmat(1,1,N-1),'full');
    X_lat = sdpvar(repmat(nx_lat,1,N),repmat(1,1,N),'full');
    eps1_lat = sdpvar(repmat(nx_lat,1,N-1),repmat(1,1,N-1), 'full');
    eps2_lat = sdpvar(repmat(nx_lat,1,N-1),repmat(1,1,N-1), 'full');
    
    objective = 0;
    constraints = []; % Constraints
    for k = 1:N-2
      constraints = [constraints, ...
          X_long{k+1} == A_long*X_long{k} + B_long*U_long{k}, ...
          X_lat{k+1} == A_lat*X_lat{k} + B_lat*U_lat{k}, ...
          ...
          param.Xcons_long(:,1) + eps1_long{k} <= X_long{k+1} <= param.Xcons_long(:,2) + eps2_long{k}, ...
          param.Xcons_lat(:,1) + eps1_lat{k} <= X_lat{k+1} <= param.Xcons_lat(:,2) + eps2_lat{k}, ...
          ...
          param.Ucons_long(:,1) <= U_long{k} <= param.Ucons_long(:,2), ...
          param.Ucons_lat(:,1) <= U_lat{k} <= param.Ucons_lat(:,2), ...
          ...
          param.UrateCons_long(:,1) <= U_long{k+1} - U_long{k} <= param.UrateCons_long(:,2), ...
          param.UrateCons_lat(:,1) <= U_lat{k+1} - U_lat{k} <= param.UrateCons_lat(:,2), ...
          ...
          -1 <= U_lat{k} + U_long{k}(1)/0.1274 <= 1, ...
          -1 <= -U_lat{k} + U_long{k}(1)/0.1274 <= 1, ...
          ...
          -0.2 <= (U_long{k+1} - U_long{k}) + (U_lat{k+1} - U_lat{k}) <= 0.2, ...
          -0.2 <= (U_long{k+1} - U_long{k}) - (U_lat{k+1} - U_lat{k}) <= 0.2, ...
          ...
          eps1_long{k} == 0, eps2_long{k} == 0, eps1_lat{k} == 0, eps2_lat{k} == 0, ...
          ...
          param.Xcons_long_add*X_long{k+1} <= 0]; 
      objective = objective + X_long{k}'*param.Q_long*X_long{k} + U_long{k}'*param.R_long*U_long{k} + ...
          X_lat{k}'*param.Q_lat*X_lat{k} + U_lat{k}*param.R_lat*U_lat{k} + ...
          ...
          eps1_long{k}'*param.S_long*eps1_long{k} + eps2_long{k}'*param.S_long*eps2_long{k} + ...
          eps1_lat{k}'*param.S_lat*eps1_lat{k} + eps2_lat{k}'*param.S_lat*eps2_lat{k} + ...
          ...
          param.v_long * norm(eps1_long{k},1) + param.v_long * norm(eps2_long{k},1) + ...
          param.v_lat * norm(eps1_lat{k},1) + param.v_lat * norm(eps2_lat{k},1); 
    end
    constraints = [constraints, ...
        param.Xcons_long(:,1) + eps1_long{N-1} <= X_long{N} <= param.Xcons_long(:,2) + eps2_long{N-1},  ...
        param.Xcons_lat(:,1) + eps1_lat{N-1} <= X_lat{N} <= param.Xcons_lat(:,2) + eps2_lat{N-1},  ...
        ...
        X_long{N} == A_long*X_long{N-1}+B_long*U_long{N-1}, ...
        X_lat{N} == A_lat*X_lat{N-1}+B_lat*U_lat{N-1}, ...
        ...
        param.Ucons_long(:,1) <= U_long{N-1} <= param.Ucons_long(:,2), ...
        param.Ucons_lat(:,1) <= U_lat{N-1} <= param.Ucons_lat(:,2), ...
        ...
        eps1_long{N-1} == 0, eps2_long{N-1} == 0, eps1_lat{N-1} == 0, eps2_lat{N-1} == 0
        ];
    %constraints = [constraints, X{N} == A*X{N-1}+B*U{N-1}];
    objective = objective + ...
        X_long{N-1}'*param.Q_long*X_long{N-1} + U_long{N-1}'*param.R_long*U_long{N-1} +...
        X_lat{N-1}'*param.Q_lat*X_lat{N-1} + U_lat{N-1}'*param.R_lat*U_lat{N-1} + ...
        ...
        eps1_long{N-1}'*param.S_long*eps1_long{N-1} + eps2_long{N-1}'*param.S_long*eps2_long{N-1} + ...
        eps1_lat{N-1}'*param.S_lat*eps1_lat{N-1} + eps2_lat{N-1}'*param.S_lat*eps2_lat{N-1} + ...
        ...
        param.v_long * norm(eps1_long{N-1},1) + param.v_long * norm(eps2_long{N-1},1) + ...
        param.v_lat * norm(eps1_lat{N-1},1) + param.v_lat * norm(eps2_lat{N-1},1) + ...
        ...
        X_long{N}'*param.P_long*X_long{N} + ...; % Final cost
        X_lat{N}'*param.P_lat*X_lat{N};
    
    % parameter for initial condition
    info = sdpvar(nx_long + nx_lat + nu_long + nu_lat,1);
    constraints = [constraints, ...
        X_long{1} == info(1:nx_long), ...
        X_lat{1} == info((nx_long + nu_long + 1):(nx_long + nu_long + nx_lat)), ...
        ...
        param.UrateCons_long(:,1) <= U_long{1} - info((nx_long+1):(nx_long + nu_long)) <= param.UrateCons_long(:,2), ...
        param.UrateCons_lat(:,1) <= U_lat{1} - info((nx_long + nu_long + nx_lat + 1):(nx_long + nu_long + nx_lat + nu_lat)) <= param.UrateCons_lat(:,2)];

    ops = sdpsettings('solver','quadprog');
    yalmip_optimizer = optimizer(constraints,objective,ops, info, [U_lat{1}; U_long{1}]);
end